# 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까?
- 재사용할 수 있는 로직 관리 방식, 사용자 정의 훅과 고차 컴포넌트 비교
## 사용자 정의 훅
- 서로 다른 컴포넌트 내부에서 같은 로직을 공유하고자 할 때 주로 사용
- 고차 컴포넌트와 달리 **리액트에서만 사용가능**
- **반드시 `use`로 시작하는 함수** 👉 가독성 향상
- `HTTP`요청하는 `fetch`를 기반으로 한 사용자 정의 훅을 만드는 예제

    ```tsx
    import { useEffect, useState } from 'react'
    
    // HTTP 요청을 하는 사용자 정의 훅
    function useFetch<T>(
        url: string,
        { method, body } : {method: string; body?:XMLHttpRequestBodyInit},
    ){
        // 응답 결과
        const [result, setResult] = useState<T | undefined>()
        // 요청 중 여부
        const [isLoading, setIsLoading] = useState<boolean>(false)
        // 2xx 3xx로 정상 응답인지 여부
        const [ok, setOk] = useState<boolean | undefined>()

        // HTTP status
        const [status, setStatus] = useState<number | undefined>()

        useEffect(() => {
            const abortController = new AbortController()

            ;(async () => {
                setIsLoading(true)

                const response = await fetch(url, {
                    method,
                    body,
                    signal: abortController.signal,
                })

                setOk(response.ok)
                setStatus(response.status)

                if (response.ok){
                    const apiResult = await response.json()
                    setResult(apiResult)
                }

                setIsLoading(false)
            })()

            return () => {
                abortController.abort()
            }
        }, [url, method, body])

        return { ok, result, isLoading, status }
    }

    interface Todo {
        userId: number
        id: number
        title: string
        completed: boolean
    }

    export default function App() {
        // 사용자 지정 훅 사용
        const { isLoading, result, status, ok } = useFetch<Array<Todo>>(
            'https://jsonplaceholder.typicode.com/todos',
            {
                method: 'GET',
            },
        )

        useEffect(() => {
            if (!isLoading) {
                console.log('fetchResult >>', status)
            }
        }, [status, isLoading])

        return (
            <div>
                {ok
                    ? (result || []).map(({userId, title}, index) => (
                        <div key={index}>
                            <p>{userId}</p>
                            <p>{title}</p>
                        </div>
                    ))
                : null}
            </div>
        )
    }
    ```
- 만약 `use`로 시작하지 않는다면 에러가 뜸(react-hook를 사용할 수 있는 곳이 한정되어 있기 때문)
    ```tsx
    // 이름을 useFetch에서 fetch로 변경
    function fetch<T>(
        url: string
        {method, body} : {method: string; body?: XMLHttpRequestBodyInit},
    ){
        // React Hook "useState" is called in function "fetch" that is neither
        // a React function component nor a custom React Hook function. React Component
        // names must start with an uppercase letter. (react-hooks/rules-of-hooks)
        const [result, setResult] = useState<T | undefined>()
        // ...
    }
    ```

## 고차 컴포넌트
- (HOC, Higher Order Component), 컴포넌트 자체의 로직을 재사용하기 위한 방법
- 고차 함수(Higher Order Function)의 일종으로 자바스크립트의 일급 객체, 함수의 특징을 이용하므로 다른 자바스크립트 환경에서 널리 쓰일 수 있음

### React.memo란?
- props의 변화가 없음에도 컴포넌트의 렌더링을 방지하기 위해 만들어진 리액트의 고차 컴포넌트
- 렌더링하기 전 props를 비교해 이전과 props가 같다면 렌더링 자체를 생략하고 이전에 기억해 둔 컴포넌트 반환
- `PureComponent`와 매우 유사
- `useMemo`로도 구현 가능

### 고차 함수 만들어보기
- 고차 함수란? : 함수를 인수로 받거나 결과를 반환하는 함수
- ex) `Array.prototype.map`, `Array.prototype.forEach`, `Array.prototype.reduce`
- 리액트에서의 고차 함수
    ```jsx
    // setState 구현 예제
    // 즉시 실행 함수로 setter를 만든다.
    const setState = (function () {
        // 현재 index를 클로저로 가둬놔서 이후에도 계속 동일한 index에 접근할 수 있도록 한다.
        let currentIndex = index
        return function (value) {
            global.states[currentIndex] = value
            // 컴포넌트를 렌더링한다. 실제로 컴포넌트를 렌더링하는 코드는 생략
        }
    })
    ```
- 직접 구현
    ```jsx
    function add(a) {
        return function (b) {
            return a + b
        }
    }

    const result = add(1)   //  여기서 result는 앞서 반환한 함수를 가리킨다.
    const result2 = result(2) // 비로소 a와 b를 더한 3이 반환
    ```

### 고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기
- 사용자 인증 정보에 따라서 인증된 사용자에게 개인화된 컴포넌트를, 그렇지 않은 사용자에게는 별도로 정의된 공통 컴포넌트를 보여주는 시나리오 예제
    ```jsx
    interface LoginProps {
        loginRequired? : boolean
    }

    function withLoginComponent<T>(Component: ComponentType<T>) {
        return function (props: T & LoginProps) {
            const { LoginRequired, ...restProps } = props

            if (loginRequired) {
                return <>로그인이 필요합니다.</>
            }

            return <Component {...(restProps as T)} />
        }
    }

    // 원래 구현하고자 하는 컴포넌트를 만들고, withLoginComponent로 감싸기만 하면 됨
    // 로그인 여부, 로그인이 안 되면 다른 컴포넌트를 렌더링하는 책임은 모두
    // 고차 컴포넌트인 withLoginComponent에 맡길 수 있어 매우 편리하다.

    const Component = withLoginComponent((props: { value: string }) => {
        return <h3>{props.value}</h3>
    })

    export default function App() {
        // 로그인 정보를 가져옴
        const isLogin = true
        return <Component value="text" loginRequired={isLogin} />
        // return <Component value="text" />
    }
    ```
- 고차 컴포넌트는 컴포넌트 전체를 감쌀 수 있다는 점에서 사용자 정의 훅보다 더욱 큰 영향력을 컴포넌트에 미칠 수 있음
- 컴포넌트의 결과물에 영향을 미칠 수 있는 다른 공통된 작업을 처리할 수 있음

### 고차 컴포넌트를 구현 시 주의할 점
1. `with`로 시작하는 이름을 사용해야함(리액트 커뮤니티의 관습)
    - 강제된 것은 아니지만 가독성에 도움이 됨
2. 부수효과를 최소화 해야한다.
    - 반드시 컴포넌트를 인수로 받게 되는데, 반드시 컴포넌트의 `props`를 임의로 수정, 추가, 삭제하는 일은 없어야 한다.
    - 만약 기존 컴포넌트에서 사용하는 `props`를 수정하거나 삭제한다면 고차 컴폰너트를 사용하는 쪽에서는 언제 `props`가 수정될 지모른다는 우려를 가지고 개발해야 하는 불편함이 생김
    - 추가적으로 정보를 줄 목적이라면 별도 `props`를 추가하는 방법이 좋다.
3. 너무 많은 컴포넌트를 감쌀 경우 복잡성이 커짐, 최소한으로 사용하는 것이 좋음
    - 결과로 어떤것이 나올지 예측하기 어려움

## 사용자 정의 훅과 고차 컴포넌트 중 무엇을 써야 할까

### 사용자 정의 훅이 필요한 경우
- 단순히 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있다면 사용자 정의 훅을 사용하는 것이 좋음
- 사용자 정의 훅은 그 자체로는 렌더링에 영향을 미치지 못하기 때문에 사용이 제한적이므로 반환하는 값을 바탕으로 무엇을 할지 개발자에게 달려있음
- 개발자가 훅을 원하는 방향으로만 사용할 수 있음(컴포넌트 내부 영향 최소화)

```jsx
// 사용자 정의 훅을 사용하는 경우
function HookComponent() {
    // useLogin은 단순히 loggedIn 값만 제공, 처리는 컴포넌트 내부에서 -> 부수효과가 비교적 제한
    const { loggedIn } = useLogin()

    useEffect(() => {
        if (!loggedIn) {
            //do something...
        }
    }, [loggedIn])
}

// 고차 컴포넌트를 사용하는 경우
const HOCComponent = withLoginComponent(() => {
    // 어떤 결과물을 낼지는 실행하기 전에는 모른다
    // do something...
})
```

### 고차 컴포넌트를 사용해야 하는 경우
- 만약 로그인되지 않은 어떤 사용자가 컴포넌트에 접근하려 할 때 애플리케이션 관점에서 컴포넌트를 감추고 로그인을 요구하는 공통 컴포넌트를 노출하는 것이 좋을 수 있음
- 사용자 정의 훅은 해당 컴포넌트가 반환하는 렌더링 결과물에까지 여향을 미치기 어렵기에 중복처리가 해당 사용자 정의 훅을 사용하는 애플리케이션 전반에 걸쳐 나타나게 될 것이므로 고차 컴포넌트를 사용해 처리하는 것이 좋음 
```jsx
// 사용자 정의 훅을 사용하는 경우
function HookComponent() {
    const { loggedIn } = useLogin()

    if (!loggedIn) {
        return <LoginComponent />
    }

    return <>안녕하세요</>
}

// 고차 컴포넌트를 사용하는 경우
const HOCComponent = withLoginComponent(() => {
    // loggedIn state의 값을 신경 쓰지 않고 그냥 컴포넌트에 필요한 로직만 추가해서 간단
    // loggedIn state에 따른 제어는 고차 컴포넌트에서 해줌
    return <>안녕하세요</>
})
```
### 결론
- 렌더링의 결과물(함수 컴포넌트의 반환값)에도 영향을 미치는 공통 로직 👉 고차 컴포넌트
- 단순히 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있음 👉 사용자 정의 훅

## 정리

|구분|사용자 정의 훅|고차 함수(컴포넌트)|
|:---:|:---:|:---:|
|공통점|중복 코드를 줄여 코드의 재사용성 향상||
|접두어|`use`|`with`|
|사용가능|리액트에서만 사용 가능|자바스크립트 환경에서 사용 가능|
|사용|단순히 리액트에서 제공하는 훅으로만 공통 로직을 격리할 수 있을때|렌더링의 결과물(함수 컴포넌트의 반환값)에도 영향을 미치는 공통 로직을 만들고자 할 때|
|장점|렌더에 직접 작용하지 않아 가벼움|렌더링 결과물에 영향을 미치는 공통 로직 처리가능|
|한계|컴포넌트 결과에는 영향을 미칠 수 없음|실행 전까지 결과가 어떻게 나올지 모름|
|예시|`useState`, `useEffect`, 등등|`React.memo`|
# 이벤트 루프와 비동기 통신의 이해
- 자바스크립트는 싱글 스레드로 한번에 하나의 작업만 동기 방식으로 처리할 수 있음

|구분|동기(synchronous)|비동기(asynchronous)|
|:---:|:---:|:---:|
|작업 처리 방식|직렬|병렬|
|설명|요청이 시작된 이후 다른 작업을 처리할 수 없음|한 번에 여러 작업 수행 가능|

## 싱글 스레드 자바스크립트

### 프로세스(Proccess)
- 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위

### 스레드(Thread)
- 하나의 프로그램에는 하나의 프로세스만이 할당되므로, 하나의 프로그램 내부에서 동시에 여러 개의 복잡한 작업을 수행하기 위해 탄생한 더 작은 실행 단위
- 하나의 프로세스는 여러 개의 스레드를 가질 수 있음
- 스레드끼리는 메모리를 공유할 수 있으며, 작업을 동시에 수행할 수 있음

### 자바스크립트가 싱글 스레드인 이유
1. 멀티 스레드의 단점
   - 멀티 스레드의 대표적인 단점인 처리의 복잡성
   - 같은 자원에 대해 여러 번 수정하는 등 동시성 문제의 발생
   - 하나의 스레드에서의 문제는 같은 자원을 공유하는 다른 스레드에서도 문제가 생길 수 있음
2. 자바스크립트의 역할
   - 최초의 자바스크립트는 브라우저에서 HTML을 그리는 데 한정적인 도움을 주는 보조적인 역할이었으며, 당시 멀티 스레드에 대한 개념이 대중화 되기 이전이었음
3. DOM 조작 시의 문제점
   - 동시에 여러 스레드가 DOM을 조작할 경우, 동시성 문제가 치명적일 수 있음

### Run-to-completion
- 하나의 코드가 실행하는데 오래 걸리면 뒤이은 코드가 실행되지 않는 특징
- 동시성을 고려하지 않아도 되는 장점 / 웹페이지 UX상의 단점
- 자바스크립트가 싱글 스레드로 만들어져있기 때문
- 하지만 **자바스크립트는 비동기적으로 동작하는데 이는 이벤트 루프 때문**이다

## 이벤트 루프란?(V8 기준)
- ECMAScript 표준은 아니며, 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어짐
- V8(Spider Monkey) 같은 현대 자바스크립트 런타임 엔진에는 자바스크립트 코드를 효과적으로 실행하기 위한 여러 가지 장치들이 마련되어있음

### 호출 스택과 이벤트 루프
- 자바스크립트에서 수행해야할 코드나 함수를 순차적으로 담아두는 스택

```js
1  function bar(){
2    console.log('bar')
3  }
4
5  function baz(){
6     console.log("baz")
7  }
8
9  function foo(){
10    console.log('foo')
11    bar()
12    baz()
13 }
14
15 foo()
```

- 호출 스택 처리과정
  > 1. 15번째 줄 foo()가 호출스택에 먼저 들어감.
  > 2. `foo()` 내부에 `console.log`가 존재 하므로 호출 스택에 추가
  > 3. `console.log` 실행 (`foo()`는 호출 스택에 존재)
  > 4. `bar()`가 호출 스택에 들어감
  > 5. `bar()` 내부에 `console.log` 가 존재하므로 호출 스택에 추가
  > 6. `console.log` 실행 (`foo()`, `bar()`는 아직 호출 스택에 존재)
  > 7. 더 이상 `bar()`에 남은 것이 없으므로 호출스택에서 제거 (`foo()`는 호출 스택에 존재)
  > 8. `baz()`가 호출 스택에 들어감
  > 9. `bar()` 내부에 `console.log` 가 존재하므로 호출 스택에 추가
  > 10. `console.log` 실행 (`foo()`, `baz()`는 아직 호출 스택에 존재)
  > 11. 더 이상 `baz()`에 남은 것이 없으므로 호출 스택에서 제거 (`foo()`는 호출 스택에 존재)
  > 12. 더 이상 `foo()`에 남은 것이 없으므로 호출 스택에서 제거 
  > 13. 호출 스택이 비워짐


- **이벤트 루프란? 호출 스택이 비어 있는지 여부를 확인하는 것**
- 단순히 이벤트 루프만의 단일 스레드 내부에서 이 호출 스택 내부에 수행해야할 작업이 있는지 확인하고 수행해야할 코드가 있다면 자바스크립트 엔진을 이용해 실행

### 비동기 작업 실행

```js
1  function bar(){
2    console.log('bar')
3  }
4
5  function baz(){
6     console.log("baz")
7  }
8
9  function foo(){
10    console.log('foo')
11    setTimeout(bar(), 0)  // setTimeout만 추가
12    baz()
13 }
14
15 foo()
```

- 호출 스택 처리과정
  > 1. 15번째 줄 foo()가 호출스택에 먼저 들어감.
  > 2. `foo()` 내부에 `console.log`가 존재 하므로 호출 스택에 추가
  > 3. `console.log` 실행 (`foo()`는 호출 스택에 존재)
  > 4. `setTimeout(bar(),0)`가 호출 스택에 들어감
  > 5. 타이머 이벤트가 실행, 태스크 큐로 들어가고, 그 대신 바로 스택에서 제거
  > 6. `baz()`가 호출 스택에 들어감
  > 7. `bar()` 내부에 `console.log` 가 존재하므로 호출 스택에 추가
  > 8. `console.log` 실행 (`foo()`, `baz()`는 아직 호출 스택에 존재)
  > 9. 더 이상 `baz()`에 남은 것이 없으므로 호출 스택에서 제거 (`foo()`는 호출 스택에 존재)
  > 10. 더 이상 `foo()`에 남은 것이 없으므로 호출 스택에서 제거 
  > 11. 호출 스택이 비워짐
  > 12. 이벤트 루프 호출 스택이 비워져 있다는 것을 확인하고, 태스크 큐를 확인, 4번 내용이 있어 `bar()`를 호출 스택에 넣음
  > 13. `bar()` 내부에 `console.log`가 존재 하므로 호출 스택에 들어감
  > 14. `console.log` 실행(`bar()`는 호출 스택에 존재)
  > 15. 더 이상 `bar()`에 남은 것이 없으므로 호출 스택에서 제거

- 비동기 함수는 메인 스레드가 아닌 태스크 큐가 할당되는 별도의 스레드에서 수행
- 이 스레드는 `브라우저`나 `Node.js`의 역할 => **자바스크립트 외부에서 실행**
- 따라서 비동기 작업을 수행할 수 있음

## 태스크 큐와 마이크로 태스크 큐
### 태스크 큐
- 실행해야할 태스크의 집합
- 대표적인 작업) `setTimeout`, `setInterval`, `setImmediate`
- 이벤트 루프에 속해 있으며 1개 이상일 수 있음
- **Set 자료구조** 형태
- 태스크 큐의 실행해야하는 태스크 -> 비동기 함수의 콜백 함수나 이벤트 핸들러 등

### 마이크로 태스크 큐
- 이벤트 루프에 속해 있는 하나의 태스크 큐
- 대표적인 작업) `Promise`, `process.nextTick`, `queueMicroTask`, `MutationObserver` 
- 기존 태스크 큐보다 우선권을 가짐
- Promise가 setTimeout, setInterval보다 빨리 실행됨
- 마이크로 태스크 큐가 비워져야 기존 태스크 큐를 실행할 수 있음
- **마이크로 태스크 > 렌더링 > 태스크 큐** / 각 마이크로 태스크 큐가 끝날 때마다 렌더링 기회가 있음
    
    ```js
    fucntion foo(){
        console.log("foo")
    }

    function bar() {
        console.log('bar')
    }

    function baz(){
        console.log('baz')
    }

    setTimeout(foo, 0)

    Promise.resolve().then(bar).then(baz)
    ```

## 예시
```html
<html>
    <body>
        <ul>
            <li>동기 코드: <button id="sync">0</button></li>
            <li>태스크: <button id="macrotask">0</button></li>
            <li>마이크로 태스크: <button id="microtask">0</button></li>
        </ul>

        <button id="macro_micro">모두 동시 실행</button>
    </body>
    <script>
        const button = document.getElementById('run')
        const sync = document.getElementById('sync')
        const macrotask = document.getElementById('macrotask')
        const microtask = document.getElementById('microtask')
        
        const macro_micro = document.getElementById('macro_micro')

        // 동기 코드로 버튼 1부터 렌더링
        sync.addEvenlistener('click', function(){
            for (let i = 0; i <= 100000 ; i ++){
                sync.innerHTML = i
            }
        })

        // setTimeout으로 태스크 큐에 작업을 넣어서 1부터 렌더링
        macrostask.addEventListener('click', function (){
            for(let i = 0; i<= 100000; i++){
                setTimeout(()=>{
                    macrotask.innerHTML = i
                }, 0)
            }
        })

        // queueMicrotask로 마이크로 태스크 큐에 넣어서 1부터 렌더링
        microtask.addEventlistener('click', function(){
            for(let i = 0; i <= 100000 ; i++){
                queueMicrotask(() => {
                    microtask.innerHTML = i
                })
            }
        })

        macro_micro.addEventListener('click', function() {
            for (let i = 0; i <= 100000 ; i ++){
                sync.innerHTML = i

                setTimeout(() => {
                    macrotask.innerHTML = i
                }, 0)

                queueMicrotask(() => {
                    microtask.innerHTML = i
                })
            }
        })
    </script>
</html>
```

- 실행 순서
  > - 동기 코드는 우리가 예상했듯, 해당 연산, 100,000까지 숫자가 올라가기 전까지는 렌더링되지 않다가 for 문이 끝나야 비로소 렌더링 기회를 얻으며, 100,000이라는 숫자가 한번에 나타남 <br>
  > - 태스크 큐(`setTimeout`)는 모든 `setTimeout` 콜백이 큐에 들어가기 전까지는 잠까느이 대기 시간을 갖다가 1부터 100,000까지 순처적으로 렌더링 된다<br>
  > - 마이크로 태스크 큐(queueMicrotask)는 동기 코드와 마찬가지로 렌더링이 되지않다가 100,000까지 다 끝난 이후에야 한 번에 렌더링이 일어난다 <br>
  > - 모든 것을 동시 실핼했을 경우 동기 코드와 마이크로 태스크 큐만 한 번에 100000까지 올라가고, 태스크 큐만 앞선 예제처럼 순차적으로 렌더링 된다.


- 마이크로 태스크 큐와 태스크 큐 사이에서 렌더링이 일어나는 지 확인하는 예제
  ```js
  console.log('a')

  setTimeout(() => {
    console.log("b")
  })

  Promise.resolve().then(() => {
    console.log("c")
  })

  window.requestAnimationFrame(() => {
    console.log('d')
  })
  // a -> c -> d -> b
  ```


## 정리

1. 자바스크립트는 싱글 스레드를 기반으로 한다.(동기 처리)
2. 비동기 작업을 하기 위해 태스크 큐를 실행하는 스레드를 외부(브라우저 혹은 Node.js)에서 실행
3. 이벤트 루프란, 호출 스택과 태스크 큐에 작업이 있는지 확인하는 것(호출 스택 -> 태스크 큐)
4. 태스크 큐에는 마이크로 태스크 큐가 있으며, 마이크로 태스크 큐가 태스크 큐보다 먼저 실행되고, 마이크로 태스크 큐 실행 이후 렌더링 기회가 주워진다.

- 이벤트 루프 순서
    - 호출 스택 확인 -> 마이크로 태스크큐 -> 렌더링 -> 태스크 큐
# 클래스
## 클래스란?
- 특정한 객체를 만들기 위한 일종의 템플릿
- 16.8버전 이전에는 클래스 개념 X -> 함수로 대체

- 클래스 예제
```js
// Car 클래스 선언
class Car {
    // constructor 생성자 - 객체 초기화
    constructor(name) {
        this.name = name
    }

    // 메서드
    honk() {
        console.log(`${this.name}이 경적을 울립니다!`)
    }

    // 정적 메서드
    static hello(){
        console.log('저는 자동차입니다.')
    }

    // setter
    set age(value){
        this.carAge = value
    }

    // getter
    get age(){
        return this.carAge
    }
}

// Car 클래스를 활용해 car 객체를 만들었다.
const myCar = new Car('자동차')

// 메서드 호출
myCar.honk()

// 정적 메서드는 클래스에서 직접 호출
Car.hello()

// 정적 메서드는 클래스로 만든 객체에서는 호출할 수 없음
myCar.hello()

// setter를 만들면 값을 할당할 수 있다.
myCar.age = 32

// getter로 값을 가져올 수 있다.
console.log(myCar.age, myCar.name) // 32 자동차
```

### `constructor`
- 생성자, 객체를 생성하는 메서드
- 객체당 하나만 사용 가능, 생략 가능

### 프로퍼티
- 클래스 인스턴스 생성 시 내부에 정의할 수 있는 속성값
```js
class Car{
    constructor(name){
        // property
        this.name = name
    }
}

const myCar = new Car('자동차') // property 전달
```

- 접근 제한자
    - ES2019에 `#`을 통한 private선언 가능
    - Typescript 사용 시 private, protected, public 사용 가능
    - JS default : `public`
    - `_`으로 컨벤션을 통한 private를 선언, 하지만 접근은 가능(말 그대로 컨벤션)

### getter
- 클래스 내부 속성값을 가져올 때 사용
- `get`을 앞에 붙여야함
```js
class Car{
    constructor(name){
        this.name = name
    }

    get firstCharacter(){
        return this.name[0]
    }
}

const myCar = new Car("자동차")
myCar.firstCharacter // 자
```


### setter
- 클래스 내부 속성값을 할당할 때 사용
- `set`을 앞에 붙여야함
```js
class Car{
    constructor(name){
        this.name = name
    }

    get firstCharacter(){
        return this.name[0]
    }

    set firstCharacter(char){
        this.name = [char, ...this.name.slice(1)].join("")
    }
}

const myCar = new Car("자동차")
myCar.firstCharacter // 자
myCar.firstCharacter = '차' // 자

console.log(myCar.firstCharacter, myCar.name) // 차, 차동차
```
### 인스턴스 메서드
- 프로토타입 메서드(prototype): prototype에 선언된다.
  ```js
  class Car {
    constructor(name){
        this.name = name
    }
    // 인스턴스 메서드 정의
    hello() {
        console.log(`안녕하세요, ${this.name}입니다.`)
    }
  }
  
  // 선언
  const myCar = new Car("자동차")
  myCar.hello() // 안녕하세요 자동차입니다.

  Object.getPrototypeOf(myCar) // {constructor: f, hello:f}
  ```
- 프로토타입 메서드는 클래스의 prototype에 선언되며, 다음과 같이 확인할 수 있다.
  ```js
  Object.getPrototypeOf(myCar) === Car.prototype // true

  myCar.__proto__ === Car.prototype // true
  ```
  - `__proto__`는 가급적 사용하지 않기 (브라우저와의 호환성만을 위해 존재하는 기능)

- 인스턴스 메서드 실행 경위(`myCar`) : **프로토타입 체이닝**
  1. `myCar` -> `Class Car`
  2. `Class Car` -> `Car` prototype `hello`
  3. `hello`에 인자를 넘겨주고 실행(`this` 사용가능 - `Class Car`에 들어와있기 때문에)


### 정적 메서드
- 클래스의 인스턴스 메서드가 아닌 이름으로 호출할 수 있는 메서드

```js
class Car{
    static hello(){
        console.log('안녕하세요!')
    }
}

const myCar = new Car()

myCar.hello()   // Uncaught TypeError: myCar.hello is not a function
Car.hello()     // 안녕하세요!
```
- 정적 메서드는 클래스로 생성된 인스턴스의 prototype에 정의되지 않아 생성된 인스턴스에서 접근할 수 없다.(`this`가 클래스 자신(`Car`)을 가리킴)

- 장점
  - 인스턴스 없이 사용
  - 객체 생성 없이 재사용 가능
  - 애플리케이션 전역에서 사용하는 유틸 함수가 자주 사용됨

### 상속
- 기존 클래스를 상속받아 자식 클래스에서 기존 클래스를 확장하는 개념(`extends`)
- 예시
  ```js
  class Car {
    constructor(name) {
        this.name = name
    }

    honk(){
        console.log(`${this.name} 경적을 울립니다!`)
    }
  }

  class Truck extends Car{
    constructor (name){
        super(name) // 상위 클래스를 이용하여 정의 -> 상위 클래스와 같이 활용함
    }
    
    // 상위 클래스는 없는 자식 클래스의 확장
    load() {
        console.log('짐을 싣습니다.')
    }
  }

  const myCar = new Car("자동차")
  myCar.honk()  // 자동차 경적을 울립니다!

  const truck = new Truck('트럭')
  // 확장
  truck.load()  // 짐을 싣습니다!
  // 상위 클래스의 인스턴스 메서드도 사용 가능
  truck.honk()  // 트럭 경적을 울립니다!
  ```

## 클래스와 함수의 관계
- ES6 이전에는 프로토타입을 활용해 클래스의 작동 방식을 구현(ES6 이후 `클래스`가 나옴)
- **클래스가 작동하는 방식은 자바스크립트의 프로토타입을 활용하는 것**

- 클래스 코드
```js
class Car {
  constructor(name) {
    this.name = name
  }

  honk() {
    console.log(`${this.name}이 경적을 울립니다!`)
  }

  static hello() {
    console.log('저는 자동차입니다')
  }

  set age(value) {
    this.carAge = value
  }

  get age() {
    return this.carAge
  }
}
```
- 바벨로 변환
```js
'use strict'

// 클래스가 함수처럼 호출되는 것을 방지
function _classCallCheck(instance, Constructor){
    if (!(instance instanceof Constructor)){
        throw new TypeError('Cannot call a class as function')
    }
}

// 프로퍼티를 할당하는 코드
function _defineProperties(target, props){
    for (var i = 0; i< props.length; i++){
        var descriptor = props[i]
        descriptor.enumerable = descriptor.enumerable || false
        descriptor.configurable = true
        if ('value' in descriptor) descriptor.writable = true
        Object.defineProperty(target, descriptor.key, descriptor)
    }
}

// 프로토타입 메서드와 정적 메서드를 선언하는 코드
function _createClass(Contructor, protoProps, staticProps){
    if (protoProps) _defineProperties(Constructor.prototype, protoProps)
    if (staticProps) _defineProperties(Constructor, staticProps)
    Object.defineProperty(Constructor, 'prototype', {writable:false})
    return Constructor
}

var Car = /*#__PURE__*/( function (){
    function Car(name){
        _classCallCheck(this, Car)
    }

    this.name = name


    _createClass(
        Car,
        [
            {
                key: 'honk',
                value: function honk(){
                    console.log(
                        ''.concat(
                            this.name,
                            '\uC744 \uACBD\uC701\uC744 \uC6B8\uB9BD\uB2C8\uB2E4!',
                        ),
                    )
                },
            },
            {
                key: 'age',
                get: function get(){
                    return this.carAge
                },
                set: function set(value){
                    this.carAge = value
                },
            },
        ],
        [
            {
                key: 'hello',
                value: function hello(){
                    console.log('저는 자동차입니다.')
                }
            }
        ],
    )

return Car
})()
```
- 쉬운 버전
  ```js
  var Car = (function (){
    function Car(name){
        this.name = name
    }

    // 인스턴스 메서드
    Car.prototype.honk = function(){
        console.log(`${this.name}이 경적을 울립니다!`)
    }

    // 정적 메서드
    Car.hello = function() {
        console.log('저는 자동차입니다.')
    }

    // Car 객체에 속성을 직접 정의
    Object.defineProperty(Car, 'age', {
        // get - set 접근자 - 설정자
        get: function(){
            return this.carAge
        },
        set: function(value){
            this.carAge = value
        }
    })

    return Car
  })()
  ```
## 정리

### 클래스를 왜 알아야하나?
- ES6이후 16.8버전 이전까지 React의 모든 컴포넌트를 클래스를 통해 구현
- 이 기능들을 함수로 구현하기 위해서는 클래스의 작동방식을 이해하고 있어야 한다.(최근에는 함수를 주로 사용)
  
### 클래스란?

|이름|용도|
|:---:|:---:|
|`constructor`|클래스 객체 생성|
|`property`|인스턴스 생성 시 내부 정의 속성 값|
|`getter`|클래스 내부에서 값을 가져올 때|
|`setter`|클래스 내부 값을 할당할 때|
|`인스턴스 메서드`|클래스 내부에 선언한 메서드(prototype에 선언)|
|`정적 메서드`|인스턴스가 아닌 이름으로 호출하는 메서드|
|`상속`|자식 클래스에서 상위 클래스를 선언하여, 이전에 사용하던 클래스를 확장|

# 리액트 훅으로 시작하는 상태 관리
## 가장 기본적인 방법: useState와 useReducer
- `useState`의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됨
- ex)
    ```tsx
    function useCounter(initCount: number = 0) {
        const [counter, setCounter] = useState(initCount)

        function inc() {
            setCounter((prev) => prev + 1)
        }

        return { counter, inc }
    }
    ```

    - 실제 사용 예제
    ```tsx
    function useCounter(initCount: number = 0) {
        const [counter, setCounter] = useState(initCount)

        function inc() {
            setCounter((prev) => prev + 1)
        }

        return { counter, inc }
    }

    function Counter1() {
        const { counter, inc } = useCounter()

        return (
            <>
                <h3>Counter1: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }

    function Counter2() {
        const { counter, inc } = useCounter()

        return (
            <>
                <h3>Counter2: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }
    ```
- `useReducer`의 이용(`useState`와 유사)
    - 예시)
        ```tsx
        type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

        function useStateWithUseReducer<T>(initialState: T) {
            const [state, dispatch] = useReducer(
                (prev: T, action: Initializer<T>) => typeof aaction === 'function' ? action(prev) : action, initialState,
            )

            return [state, dispatch]
        }
        ```
    - `useState`를 이용한 `useReducer`
        ```tsx
        function useReducerWithUseState(reducer, initialState, initializer) {
            const [state, setState] = useState(
                initializer ? () => initializer(initialState) : initialState,
            )

            const dipatch = useCallback(
                (action) => setState((prev) => reducer(prev, action)),
                [reducer],
            )

            return [state, dispatch]
        }  
        ```

- 장점
    - 어디서든 손쉽게 재사용 가능
    - 지역적으로 상태관리 가능
- 단점
    - 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없음(**컴포넌트별 상태의 파편화**)
    - 지역 상태만 관리 가능하며, 지역 상태는 컴포넌트 내에서만 유효

- 상위 컴포넌트에서 지역 상태를 선언하여 props로 전달 방식의 상태 관리 예제
    ```tsx
    function Counter1({ counter, inc }: { counter: number; inc: () => void }) {
        return (
            <>
                <h3>Counter1: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }

    function Counter2({ counter, inc }: { counter: number; inc: () => void }) {
        return (
            <>
                <h3>Counter2: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }

    function Parent(){
        const { counter, inc } = useCounter()

        return (
            <>
                <Counter1 counter={counter} inc={inc} />
                <Counter2 counter={counter} inc={inc} />
            </>
        )
    }
    ```
    - 지역 상태 관리 개념이기에 컴포넌트 트리를 재설계할 필요가 있음


## 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기
> 클로저를 사용하는 `useState`는 컴포넌트 내부에서만 사용할 수 있어 다른 자바스크립트 실행 문맥에서 초기화돼서 관리되면? 
    - **렌더링이 되지 않음**
    ```ts
    // counter.ts
    export type State = { counter: number }

    // 상태를 아예 컴포넌트 밖에서 선언하여 각 컴포넌트가 바라보게 함
    let state: State = {
        counter: 0,
    }

    // getter
    export function get(): State {
        return state
    }

    // useState와 동일하게 구현하기 위해 게으른 초기화 함수나 값을 받을 수 있게 함
    type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

    // setter
    export function set<T>(nextState: Initializer<T>) {
        state = typeof nextState === 'function' ? nextState(state) : nextState
    }

    // Counter
    function Counter(){
        const state = get()

        function handleClick() {
            set((prev: State) => ({ counter: prev.counter + 1 }))
        }

        return (
            <>
                <h3>{state.counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }
    ```  
    - 필요 작업
        - useState, useReducer의 반환값 중 두 번째 인수가 어떻게든 호출
        - 부모 함수(부모 컴포넌트)가 리렌더링되거나 해당 함수(함수 컴포넌트)가 다시 실행(**매우 비효율적**)

- `useState`의 인수를 이용하여 억지로 렌더링 시키기
    ```ts
    function Counter1(){
        const [ count, setCount ] = useState(state)

        function handleClick() {
            // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음, 그 값을 로컬 상태값에도 넣음
            set((prev: State) => {
                const newState = { counter: prev.counter + 1 }
                // setCount가 호출되면서 컴포넌트 리렌더링
                setCount(newState)
                return newState
            })
        }

        return (
            <>
                <h3>{count.counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }

    function Counter2(){
        const [ count, setCount ] = useState(state)

        function handleClick() {
            // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음, 그 값을 로컬 상태값에도 넣음
            set((prev: State) => {
                const newState = { counter: prev.counter + 1 }
                // setCount가 호출되면서 컴포넌트 리렌더링
                setCount(newState)
                return newState
            })
        }

        return (
            <>
                <h3>{count.counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }
    ```
    - 문제점
        - 함수 컴포넌트의 렌더링을 위해 함수의 내부에 동일한 상태를 관리하는 `useState`가 존재(**중복 관리하므로 비효율적인 방식**)
        - 상태를 업데이트한 후, 같은 곳을 바라보는 다른 컴포넌트들이 리렌더링되지 않음

- `state`가 변동되면 참조하고 있는 컴포넌트를 모두 렌더링시키기
    1. 꼭 `window`sk `global`에 있어야 할 필요는 없지만 컴포넌트 외부 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야한다.
    2. 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아챌 수 있어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야한다. 이 상태 감지는 상태를 변경시키는 컴포넌트뿐만 아니라 이 상태를 참조하는 모든 컴포넌트에서 동일하게 작동해야 한다.
    3. 상태가 원시값이 아닌 객체인 경우에 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 발생해서는 안 된다, 예를 들어, `{a: 1, b: 2}`라는 상태가 있으며 어느 컴포넌트에서 `a`를 2로 업데이트 했다고 가정했을 때, 이러한 객체 값의 변화가 단순히 `b`의 값을 참조하는 컴포넌트에서는 리렌더링을 일으켜서는 안 된다.

    ```tsx
    type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

    type Store<State> = {
        // 항상 최신값을 가져와야 하므로 함수 형태
        get: () => State
        set: (action: Initializer<State>) => State
        // store의 변경을 감지하고 싶은 컴포넌트들이 자신의 callback 함수를 등록하는 곳
        // 이 스토어를 참조하는 컴포넌트는 subscribe에 컴포넌트 자기 자신을 렌더링하는 코드를 추가해 리렌더링을 유도할 수 있다
        subscribe: (callback: () => void) => void
    }

    export const createStore = <State extends unknown>(
        initialState: Initializer<State>,
    ): Store<State> => {
        // useState와 마찬가지로 초깃값을 게으른 초기화를 위한 함수와 값을 받을 수 있게 한다.
        // state의 값은 스토어 내부에서 보관해야 하므로 변수로 선언
        let state = typeof initialState !== 'function' ? initialState : initialState()

        // callbacks는 자료형에 관계없이 유일한 값을 저장할 수 있는 Set 자료구조를 사용한다.
        const callbacks = new Set<() => void>()
        // 언제든 get이 호출되면 최신값을 가져올 수 있도록 함수로 만든다.
        const get = () => state
        const set = (nextState: State | ((prev: State) => State) => {
            // 인수가 함수라면 함수를 실행하여 새로운 값을 받고,
            // 아니라면 새로운 값을 그대로 사용
            state = 
                typeof nextState === 'function' 
                ? (nextState as (prev: State) => State)(state) 
                : nextState

            // 값의 설정이 발생되면 콜백 목록을 순회하면서 모든 콜백을 실행
            callbacks.forEach((callback) => callback())

            return state
        }

        // subsscribe는 콜백을 인수로 받는다.
        const subscribe = (callback: () => void) => {
            // 받은 함수를 콜백 목록에 추가
            callbacks.add(callback)

            // 클린업 실행 시 이를 삭제해서 반복적으로 추가되는 것을 막는다.
            return () => {
                callbacks.delete(callback)
            }
        }
        return { get, set, subscribe }
    }

    ```

    - `createStore`로 만들어진 `store`의 값을 참조하고, 이 값의 변화에 따라 컴포넌트 렌더링을 유도할 사용자 정의 훅
    ```tsx
    export const useStore = <State extends unknown>(store: Store<State>) => {
        const [state, setState] = useState<State>(() => store.get())

        useEffect(()=> {
            const unsubscribe = store.subscribe(() => {
                setState(store.get())
            })
            return unsubscribe
        }, [store])
        // useEffect의 작동이 끝난 이후 callback에서 해당 함수를 제거해 callback이 계속 쌓이는 것 방지
        return [state, store.set] as const
    }
    ```

- 동작 확인
    ```tsx
    const store = createStore({ count: 0 })

    function Counter1() {
        const [state, setState] = useStore(store)

        function handleClick() {
            setState((prev) => ({ count: prev.count + 1 }))
        }

        return (
            <>
                <h3>Counter1: {state.count}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }

    function Counter2() {
        const [state, setState] = useStore(store)

        function handleClick() {
            setState((prev) => ({ count: prev.count + 1 }))
        }

        return (
            <>
                <h3>Counter2: {state.count}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }

    export default function App() {
        return (
            <div className="App">
                <Counter1 />
                <Counter2 />
            </div>
        )
    }
    ```

> 문제점 
- 스토어가 원시값이 아닌 객체인 경우, 객체의 일부만 변경될 때 객체 내의 다른 일부만 참조하는 컴포넌트 또한 리렌더링된다.

- 문제점 해결 코드
    ```tsx
    export const useStoreSelector = <State extends unknown, Value extends unknown>(
        store: Store<State>,
        selector: (state: State) => Value,
    ) => {
        const [state, setState] = useState(() => selector(store.get()))

        useEffect(() => {
            const unsubscribe = store.subscribe(() => {
                // selector를 통해 참조하고 있는 객체 값에 변동 되었을 때만 리렌더링
                const value = selector(store.get())
                setState(value)
            })

            return unsubscribe
        }, [store, selector])

        return state
    }
    ```

- 사용 코드
    ```tsx
    const store = createStore({ count: 0, text: 'hi' })

    function Counter() {
        const counter = useStoreSelector(
            store,
            useCallback((state) => state.count, []),
        )

        function handleClick() {
            store.set((prev) => ({ ...prev, count: prev.count+1 }))
        }

        useEffect(() => {
            console.log('Counter Rendered')
        })

        return (
            <>
                <h3>{counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }

    const textSelector = (state: ReturnType<typeof store.get>) => state.text

    function TextEditor() {
        const text = useStoreSelector(store, textSelector)

        useEffect(() => {
            console.log('TextEditor Rendered')
        })

        function handleChange(e: ChangeEvent<HTMLInputElement>) {
            store.set((prev) => ({ ...prev, text: e.target.value }))
        }

        return (
            <>
                <h3>{text}</h3>
                <input value={text} onChange={handleChange} />
            </>
        )
    }
    ```

- 실제 [useSubscription](https://github.com/facebook/react/blob/v18.2.0/packages/use-subscripbtion/src/useSubscription.js) 작성 코드를 보면 위 코드의 문제점인 `useEffect` 내부 `store`나 `selector`가 들어가 있어 불필요한 리렌더링이 발생하는데, `useSubscription`에는 이를 방지하기 위해 예외 처리를 추가해 변경이 알려지는 동안은 `store`, `selector`의 변경을 무시하고 한정적으로 원하는 값을 반환하게끔 훅이 작성되어 있다.

## useState와 Context를 동시에 사용해 보기
- 이전까지 만든 상태 관리 예제의 문제점: 훅과 스토어를 사용하는 구조는 반드시 하나의 스토어만 가지게 된다.(전역 상태)

### 해결책
- `createStore`를 이용해 동일한 타입으로 스토어를 여러 개 만드는 것
    -> 만들 때마다 `useStore` 같은 훅을 동일한 수로 만들어야하며, 가독성이 떨어져 사용에 어려움이 있다.

- `Context`를 활용하는 방법

    ```tsx
    // Context를 생성하면 자동으로 스토어도 함께 생성된다.
    export const CounterStoreContext = createContext<Store<CounterStore>>(
        createStore<CounterStore>({ count: 0, text: 'hello' }),
    )

    export const CounterStoreProvider = ({
        initialState,
        children,
    }: PropsWithChildren<{
        initialState: CounterStore
    }>) => {
        const storeRef = useRef<Store<CounterStore>>()

        // 스토어를 생성한 적이 없다면 최초에 한 번 생성한다.
        if (!storeRef.current) {
            storeRef.current = createStore(initialState)
        }

        return (
            <CounterStoreContext.Provider value={storeRef.current}>
                {children}
            </CounterStoreContext.Provider>
        )
    }
    ```

- `useContext`를 사용해 스토어에 접근할 수 있는 새로운 훅 정의
    ```tsx
    export const useCounterContextSelector = <State extends unknown>(
        selector: (state: CounterStore) => State,
    ) => {
        const store = useContext(CounterStoreContext)

        //useStoreSelector를 사용해도 됨
        const subscription = useSubscription(
            useMemo(
                () => ({
                    getCurrentValue: () => selector(store.get()),
                    subscribe: store.subscribe,
                }),
                [store, selector],
            ),
        )
    return [subscription, store.set] as const
    }
    ```
- 새로운 훅과 `Context` 사용 예제
    ```tsx
    const ContextCounter = () => {
        const id = useId()
        const [counter, setStore] = useCounterContextSelector(
            useCallback((state: CounterStore) => state.count, []),
        )

        function handleClick() {
            setStore((prev) => ({ ...prev, count: prev.count + 1 }))
        }

        useEffect(() => {
            console.log(`${id} Counter Rendered`)
        })

        return (
            <div>
                {counter} <button onClick={handleClick}>+</button>
            </div>
        )
    }

    const ContextInput = () => {
        const id = useId()
        const [text, setStore] = useCounterContextSelector(
            useCallback((state: CounterStore) => state.text, []),
        )

        function handleChange(e: ChangeEvent<HTMLInputElement>) {
            setStore((prev) => ({ ...prev, text: e.target.value }))
        }

        useEffect(() => {
            console.log(`${id} Counter Rendered`)
        })

        return (
            <div>
                <input value={text} onChange={handleChange} />
            </div>
        )
        
    }

    export default function App() {
        return (
            <>
                {/* 0 */}
                <ContextCounter />
                {/* hi */}
                <ContextInput />
                <CounterStoreProvider initialState={{ count: 10, text: 'hello' }}>
                    {/* 10 */}
                    <ContextCounter />
                    {/* hello */}
                    <ContextInput />
                    <CounterStoreProvider initialState={{ count: 20, text: 'welcome' }}>
                        {/* 가장 가까운 context에 있는 store에서 값을 가져옴 */}
                        {/* 20 */}
                        <ContextCounter />
                        {/* welcome */}
                        <ContextInput />
                    </CounterStoreProvider>
                </CounterStoreProvider>
            </>
        )
    }
    ```
### 결론
- 상태 관리 시에 고려해야할 점 2가지
    1. useState, useReducer가 가지고 있는 한계, 컴포넌트 내부에서만 사용할 수 있는 지역 상태라는 점을 극복하기 위해 외부 어딘가에 상태를 둔다. 이는 컴포넌트의 최상단 내지는 필요한 부모가 될 수도 있고, 혹은 격리된 자바스크립트 스코프 어딘가일 수도 있다.
    2. 이 외부의 상태 변경을 각자의 방식으로 감지해 컴포넌트의 렌더링을 일으킨다.

## 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기
- Recoil, Jotai는 Context, Provider 그리고 hook을 기반으로 가능한 작은 상태를 효율적으로 관리하는 초점
- Zustand는 리덕스와 비슷하게 하나의 큰 스토어를 기반으로 상태를 관리

### 페이스북이 만든 상태 관리 라이브러리 Recoil
- 리액트 훅의 개념으로 상태 관리를 시작한 최초의 라이브러리 중 하나이며, 최소 상태 개념인 `Atom`을 처음 리액트 생태계에 선보임
- 정식 출시가 아닌 실험적으로 개발되고 운영되는 라이브러리(안정성의 문제)
- Recoil 0.7.5 기준

> RecoilRoot
- Recoil을 사용하기 위해 애플리케이션 최상단에 선언해야할 인자
    ```tsx
    export default function App() {
        return <RecoilRoot>{/* some components */}</RecoilRoot>
    }
    ```

- 내부 코드
    ```tsx
    function RecoilRoot(props: Props): React.Node {
        const { override, ...propsExceptOverride } = props

        // Recoil에 생성되는 atom과 같은 상태값을 저장하는 스토어
        const ancestorStorageRef = useStoreRef()        // AppContext가 가지고 있는 Store
        
        if (override === false && ancestorStoreRef.current !== defaultStore) {
            // If ancestorStoreRef.current !== defaultStore, it means that this RecoilRoot is not nested within another.
            return props.children
        }

        return <RecoilRoot_INTERNAL { ...propsExceptOverride } />
    }

    // useStoreRef 코드
    const AppContext = React.createContext<StoreRef>({ current: defaultStore })
    const useStoreRef = (): StoreRef => useContext(AppContext)
    
    // defaultStore 코드
    function notInAContext() {
        throw err('This component must be used inside a <RecoilRoot> component')
    }

    const defaultStore: Store = Object.freeze({
        storeID: getNextStoreID(),
        // RecoilRoot로 감싸지 않은 컴포넌트는 접근 허용 ❌
        getState: notInAContext,
        replaceState: notInAContext,
        getGraph: notInAContext,
        subscribeToTransactions: notInAContext,
        addTransactionMetadata: notInAContext,
    })

    // replaceState 코드
    const replaceState = (replacer: (TreeState) => TreeState) => {
        startNextTreeIfNeeded(storeRef.current)
        // Use replacer to get the next state:
        const nextTree = nullthrows(storeStateRef.current.nextTree)
        let replaced
        try {
            stateReplacerIsBeingExecuted = true
            replaced = replacer(nextTree)
        } finally {
            stateReplacerIsBeingExecuted = false
        }
        if (replaced === nextTree) {
            return
        }

        // ... 생략

        // Save changes to nextTree and schedule a React update:
        storeSTateRef.current.nextTree = replaced
        if (reactMode().early) {
            // 상태가 변경되면 하위 컴포넌트로 전파해 컴포넌트에 리렌더링을 일으키는 함수
            notifyComponents(storeRef.current, storeStateRef.current, replaced)
        }
        // ...

    }

    // notifyComponents 코드
    function notifyComponents(
        store: Store.
        storeState: StoreState,
        treeState: TreeState,
    ): void {
        const dependentNodes = getDownstreamNodes(
            store,
            treeState,
            treeState.dirtyAtoms,
        )
        // 의존성 검사
        for (cont key of dependentNodes) {
            const comps = storeState.nodeToComponentSubscriptions.get(key)
            if (comps) {
                // 의존성이 있는 내용들은 callback 함수들을 순회하며 호출
                for (const [_subID, [_debugName, callback]] of comps) {
                    callback(treeState)
                }
            }
        }
    }
    ```
- `RecoilRoot` 의 구조
    1. Recoil의 상태값은 RecoilRoot로 생성된 Context의 스토어에 저장
    2. 스토어의 상태값에 접근할 수 있는 함수들이 있으며, 이 함수를 활용해 상태값에 접근하거나 변경할 수 있음
    3. 값의 변경이 발생하면 이를 참조하고 있는 하위 컴포넌트에 모두 알린다.


> atom



> useRecoilValue

> useRecoilState

> 간단한 사용법

> 특징

### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai
> atom

> useAtomValue

> useAtom

> 간단한 사용법

> 특징


### 작고 빠르며 확장에도 유연한 Zustand
> Zustand의 바닐라 코드

> Zustand의 리액트 코드

> 간단한 사용법

> 특징

## 정리

# 리액트 훅으로 시작하는 상태 관리
## 가장 기본적인 방법: useState와 useReducer
- `useState`의 등장으로 리액트에서는 여러 컴포넌트에 걸쳐 손쉽게 동일한 인터페이스의 상태를 생성하고 관리할 수 있게 됨
- ex)
    ```tsx
    function useCounter(initCount: number = 0) {
        const [counter, setCounter] = useState(initCount)

        function inc() {
            setCounter((prev) => prev + 1)
        }

        return { counter, inc }
    }
    ```

    - 실제 사용 예제
    ```tsx
    function useCounter(initCount: number = 0) {
        const [counter, setCounter] = useState(initCount)

        function inc() {
            setCounter((prev) => prev + 1)
        }

        return { counter, inc }
    }

    function Counter1() {
        const { counter, inc } = useCounter()

        return (
            <>
                <h3>Counter1: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }

    function Counter2() {
        const { counter, inc } = useCounter()

        return (
            <>
                <h3>Counter2: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }
    ```
- `useReducer`의 이용(`useState`와 유사)
    - 예시)
        ```tsx
        type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

        function useStateWithUseReducer<T>(initialState: T) {
            const [state, dispatch] = useReducer(
                (prev: T, action: Initializer<T>) => typeof aaction === 'function' ? action(prev) : action, initialState,
            )

            return [state, dispatch]
        }
        ```
    - `useState`를 이용한 `useReducer`
        ```tsx
        function useReducerWithUseState(reducer, initialState, initializer) {
            const [state, setState] = useState(
                initializer ? () => initializer(initialState) : initialState,
            )

            const dipatch = useCallback(
                (action) => setState((prev) => reducer(prev, action)),
                [reducer],
            )

            return [state, dispatch]
        }  
        ```

- 장점
    - 어디서든 손쉽게 재사용 가능
    - 지역적으로 상태관리 가능
- 단점
    - 훅을 사용할 때마다 컴포넌트별로 초기화되므로 컴포넌트에 따라 서로 다른 상태를 가질 수 밖에 없음(**컴포넌트별 상태의 파편화**)
    - 지역 상태만 관리 가능하며, 지역 상태는 컴포넌트 내에서만 유효

- 상위 컴포넌트에서 지역 상태를 선언하여 props로 전달 방식의 상태 관리 예제
    ```tsx
    function Counter1({ counter, inc }: { counter: number; inc: () => void }) {
        return (
            <>
                <h3>Counter1: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }

    function Counter2({ counter, inc }: { counter: number; inc: () => void }) {
        return (
            <>
                <h3>Counter2: {counter}</h3>
                <button onClick={inc}>+</button>
            </>
        )
    }

    function Parent(){
        const { counter, inc } = useCounter()

        return (
            <>
                <Counter1 counter={counter} inc={inc} />
                <Counter2 counter={counter} inc={inc} />
            </>
        )
    }
    ```
    - 지역 상태 관리 개념이기에 컴포넌트 트리를 재설계할 필요가 있음


## 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기
- 클로저를 사용하는 `useState`는 컴포넌트 내부에서만 사용할 수 있어 다른 자바스크립트 실행 문맥에서 초기화돼서 관리되면? 
    - **렌더링이 되지 않음**
    ```ts
    // counter.ts
    export type State = { counter: number }

    // 상태를 아예 컴포넌트 밖에서 선언하여 각 컴포넌트가 바라보게 함
    let state: State = {
        counter: 0,
    }

    // getter
    export function get(): State {
        return state
    }

    // useState와 동일하게 구현하기 위해 게으른 초기화 함수나 값을 받을 수 있게 함
    type Initializer<T> = T extends any ? T | ((prev: T) => T) : never

    // setter
    export function set<T>(nextState: Initializer<T>) {
        state = typeof nextState === 'function' ? nextState(state) : nextState
    }

    // Counter
    function Counter(){
        const state = get()

        function handleClick() {
            set((prev: State) => ({ counter: prev.counter + 1 }))
        }

        return (
            <>
                <h3>{state.counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }
    ```  
    - 필요 작업
        - useState, useReducer의 반환값 중 두 번째 인수가 어떻게든 호출
        - 부모 함수(부모 컴포넌트)가 리렌더링되거나 해당 함수(함수 컴포넌트)가 다시 실행(**매우 비효율적**)

- `useState`의 인수를 이용하여 억지로 렌더링 시키기
    ```ts
    function Counter1(){
        const [ count, setCount ] = useState(state)

        function handleClick() {
            // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음, 그 값을 로컬 상태값에도 넣음
            set((prev: State) => {
                const newState = { counter: prev.counter + 1 }
                // setCount가 호출되면서 컴포넌트 리렌더링
                setCount(newState)
                return newState
            })
        }

        return (
            <>
                <h3>{count.counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }

    function Counter2(){
        const [ count, setCount ] = useState(state)

        function handleClick() {
            // 외부에서 선언한 set 함수 내부에서 다음 상태값을 연산한 다음, 그 값을 로컬 상태값에도 넣음
            set((prev: State) => {
                const newState = { counter: prev.counter + 1 }
                // setCount가 호출되면서 컴포넌트 리렌더링
                setCount(newState)
                return newState
            })
        }

        return (
            <>
                <h3>{count.counter}</h3>
                <button onClick={handleClick}>+</button>
            </>
        )
    }
    ```
    - 문제점
        - 함수 컴포넌트의 렌더링을 위해 함수의 내부에 동일한 상태를 관리하는 `useState`가 존재(**중복 관리하므로 비효율적인 방식**)
        - 상태를 업데이트한 후, 같은 곳을 바라보는 다른 컴포넌트들이 리렌더링되지 않음

## useState와 Context를 동시에 사용해 보기
## 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기
### 페이스북이 만든 상태 관리 라이브러리 Recoil
### Recoil에서 영감을 받은, 그러나 조금 더 유연한 Jotai
### 작고 빠르며 확장에도 유연한 Zustand
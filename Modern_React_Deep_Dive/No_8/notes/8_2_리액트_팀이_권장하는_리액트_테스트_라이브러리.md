# 리액트 팀이 권장하는 리액트 테스트 라이브러리
- 블랙박스 형태로 테스트가 이뤄지며, 코드가 어떻게 됐든 상관없이 의도한 대로 작동하는지를 확인하는데 좀 더 초점이 맞춰져있다.
- 가장 널리 사용되는 React Testing Library 살펴보기

## React Testing Library란?
- DOM Testing Library를 기반으로 만들어진 테스팅 라이브러리로, 리액트를 기반으로 한 데스트를 수행하기 위해 만들어짐
- 리액트 기반 환경에서 리액트 컴포넌트를 테스팅할 수 있는 라이브러리
- 실제 리액트 컴포넌트를 렌더링하지 않더라도 리액트 컴포넌트가 원하는 대로 렌더링되고 있는지 확인 가능
- **테스트 환경을 구축하는 과정을 거치지 않아 간편하고, 시간 역시 효과적으로 단축 가능**
- Provider, 훅 등 리액트를 구성하는 다양한 요소들을 테스트할 수 있음

### DOM Testing Library
- [jsdom](https://github.com/jsdom/jsdom)을 기반
- jsdom: 자바스크립트로 작성된 라이브러리로, HTML이 없는 자바스크립트만 존재하는 환경, Node.js 같은 환경에서 HTML과 DOM을 사용할 수 있도록 하는 라이브러리

    ```js
    const jsdom = require("jsdom")

    const { JSDOM } = jsdom

    const dom = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`)

    console.log(dom.window.document.querySelector('p').textContent) // Hello Wwrld
    ```

## 자바스크립트 테스트의 기초
```js
function sum(a,b) {
    return a+b
}
```
- `sum`함수 테스팅 코드
    ```js
    // 테스트 1
    // 함수를 실행했을 때의 실제 결과
    let actual = sum(1,2)
    // 함수를 실행했을 때 기대하는 결과
    let expected = 3

    if (expected !== actual) {
        throw new Error(`${expected} is not equal to ${actual}`)
    }

    // 테스트 2
    actual = sum(2, 2)
    expected = 4

    if (expected !== actual) {
        throw new Error(`${expected} is not equal to ${actual}`)
    }
    ```

> 테스트 순서
1. 테스트할 함수나 모듈을 선정
2. 함수나 모듈이 반환하길 기대하는 값 작성
3. 함수나 모듈의 실제 반환 값 작성
4. 3번의 기대에 따라 2번의 결과가 일치하는지 확인
5. 기대하는 결과를 반환한다면 테스트는 성공, 다른 결과라면 에러를 반환

> Node.js assert 활용
```js
const assert = require("assert")

function sum(a, b) {
    return a+b
}

assert.equal(sum(1, 2), 3)
assert.equal(sum(2, 2), 4)
assert.equal(sum(1, 2), 4) // AssertionError [ERR_ASSERTION] [ERR)ASSERTION]: 3 == 4
```

### 테스트 코드 작성 준비
- **어셜션(assertion) 라이브러리**: 테스트 결과를 확인할 수 있도록 도와주는 라이브러리(shoul.js, expect.js, chai, assert 등등)
- 어셜션 라이브러리와 함께 테스트의 목적이 분명하게 작성되는 것이 중요
- 좋은 테스트 코드: 다양한 테스크 코드가 작성되고 통과하는 것뿐만 아니라 어떤 테스트가 무엇을 테스트하는지 일목요연하게 보여줘야함

### 자바스크립트에서 유명한 테스팅 프레임워크
- 테스팅 프레임워크는 좋은 테스트 코드를 위한 요소들을 모두 포함
- `Jest`, `Mocha`, `Karma`, `Jasmine` 등
- 리액트에선 메타에서 작성한 `Jest`가 많이 쓰인다.(expect.js 사용) 

### Jest를 활용하여 테스트 코드 작성
- 테스트할 파일 : `math.js`
    ```js
    function sum(a, b) {
        return a + b 
    }

    module.exports = {
        sum,
    }
    ```
- 테스트 파일: math.test.js
    ```js
    const { sum } = require("./math")

    test('두 인수가 덧셈이 되어야 한다.', () => {
        expect(sum(1, 2).toBe(3))
    })

    test('두 인수가 덧셈이 되어야 한다.', () => {
        expect(sum(2, 2).toBe(3)) // 에러
    })
    ```

- 테스트 수행 결과
    ```bash
    $ npm run test
    > jest
     FAIL lessons/jest.test.js
      ✅ 두 인수가 덧셈이 되어야 한다.
      ❌ 두 인수가 덧셈이 되어야 한다. (3 ms)

      ⚫️ 두 인수가 덧셈이 되어야 한다.

      expect(received).toBe(expected) // Object.is equality

      Expected: 3
      Received: 4

        6 |
        7 | test('두 인수가 덧셈이 되어야 한다.', () => {
        8 |    expect(sum(2, 2)).toBe(3)
          |                      ^
        9 | })

        at Object.<anonymous> (lessons/jest.test.js:8:21)

    Test Suites: 1 failed, 1 total
    Tests:       1 failed, 1 passed, 2 total
    Snapshots:   0 total
    Time:        0.241 s, estimated 1 s
    Run all test suites related to changed files.
    ```
- jest(`npm run test`)로 실행했기에 `test`, `expect`등의 메서드를 import 하지 않고 사용할 수 있음(test, expect는 Node의 전역 global에 존재하지 않는 메서드임)
- jest를 비롯한 테스팅 프레임워크에는 이른바 글로벌이라 해서 실행 시에 전역 스코프에 기본적으로 넣어주는 값들이 있음
- jest 또한 실제 테스트 직전에 미리 전역스코프에 넣음

- 다음과 같은 구문을 넣어 사용할 수 있음(node 실행 가능) : 선호되지 않는 방식
    ```js
    import { expect, jest, test } from "@jest/globals"
    ```
    

## 리액트 컴포넌트 테스트 코드 작성하기
### 리액트 컴포넌트 테스트 순서
1. 컴포넌트 렌더링
2. 필요하다면 컴포넌트에서 특정 액션 수행
3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제값 비교

### 프로젝트 생성
- `create-react-app`을 통한 예제 프로젝트 생성(`react-testing-library`가 이미 포함됨)

> `App.test.tsx`가 `App.tsx`에서 테스트하는 내용
1. `<App />` 렌더링
2. 렌더링하는 컴포넌트 내부에서 "learn react"라는 문자열을 가진 DOM 요소 찾기
3. expect(linkElement).toBeInTheDocument()라는 어셜션을 활용해 2번에서 찾은 요소가 document 내부에 있는지 확인

> 리액트 컴포넌트에서 테스트하는 일반적인 시나리오는 특정한 무언가를 지닌 HTML 요소가 있는지 여부를 확인하는 방법
- `getBy...`: 인수의 조건에 맞는 요소를 반환하며, 해당 요소가 없거나 두 개 이상이면 에러를 발생시킨다. 복수 개를 찾고 싶다면 `getAllby...`를 사용
- `findBy...`: `getBy...`와 거의 유사하나 큰 차이점은 `Promise`를 반환(비동기 동작), 기본값으로 `1000ms`의 타임아웃을 가지고 있음, 복수 개를 찾고 싶다면 `findAllBy...`를 사용
- `queryBy...`: 인수의 조건에 맞는 요소를 반환하는 대신, 찾지 못한다면 null를 반환. `findBy...`와 `getBy...`는 못찾으면 에러를 발생시키지만 에러를 발생시키지 않고 싶다면 `queryBy...`를 사용, 복수 개를 찾고 싶다면 `queryAllBy...`를 사용.

> 파일 경로와 네이밍
- App.tsx, App.test.tsx의 경우와 마찬가지로 같은 디렉터리 상에 위치하는 것이 일반적
- 이름 규칙인 `*.test.{t|s}jsx`만 준수한다면 디렉터리 내부에서 명확하게 구별됨
- 대부분의 프레임워크가 이러한 이름으로 된 파일은 번들리에서 제외하므로 유용하게 사용할 수 있음

### 정적 컴포넌트
- 별도의 상태가 존재하지 않는 컴포넌트 테스팅 방법

> 코드 살펴보기
- `beforeEach`: 각 테스트(it)를 수행하기 전에 실행하는 함수, 각 테스트를 실행하기 앞서 StaticComponent 실행
- `describe`: 비슷한 속성을 가진 테스트를 하나의 그룹으로 묶는 역할, 필수요소 아님, describe 내부 describe 선언 가능
- `it`: 
    - test와 완전히 동일하며 test의 축약어(alias), 
    - it이라는 축약어를 제공하는 이유는 테스트 코드를 좀 더 사람이 읽기 쉽게 하기 위해서임
    - describe ... it (something)과 같은 형태로 작성해 두면 테스트 코드가 한결 문어체 같이 표현되어 읽기 쉬워짐
- `testId`:
    - testId는 리액트 테스팅 라이브러리의 예약어로, get 등의 선택자로 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용 가능
    - HTML의 DOM 요소에 testId 데이터셋을 선언해 두면 이후 테스트 시에 getByTestId, findByTestId 등으로 선택 가능
    - 웹에서 사용하는 querySelector([data-testid="${yourId}"])와 동일한 역할

### 동적 컴포넌트
- 상태를 관리하는 컴포넌트 테스팅

> 사용자가 useState를 통해 입력을 변경하는 컴포넌트
- `setup` 함수: 내부에서 컴포넌트를 렌더링, 테스트에 필요한 button과 input을 반환.
- `userEvent.type`: 사용자가 타이핑하는 것을 흉내내는 메서드(사용자가 타이핑 하는 것과 동일한 작동을 만들 수 있음)
    - `fireEvent`와 차이
        - userEvent는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내 낸다.
        - 예시: userEvent.click 수행시
            - fireEvent.mouseOver
            - fireEvent.mouseMove
            - fireEvent.mouseDown
            - fireEvent.mouseUp
            - fireEvent.click
    - 결론: fireEvent가 훨씬 더 빠르지만, 흉내내야할 때만 userEvent를 사용
- `jest.spyOn(window, 'alert').mockImplementation()`
    - `jest.spyOn`: Jest가 제공하는 spyOn은 어떠한 특정 메서드를 오염시키지 않고 실행이 됐는지, 또 어떤 인수로 실행됐는지 등 실행과 관련된 정보를 얻고 싶을 때 사용
    - `jest.spyOn(window, 'alert')`: window객체의 메서드 alert를 구현하지 않고 해당 메서드가 실행됐는지만 **관찰**하겠다는 뜻
    
    - `mockImplementation`: 모킹(mocking) 구현을 도와줌, Jest를 실행하는 Node.js 환경에서는 window.alert가 존재하지 않으므로 해당 메서드를 모의 함수(mock)로 구현하는 역할
    - 결론: `window.alert`를 테스트하기 위해 `jest.spyOn`을 사용해 `window.alert`를 관찰하게끔 하고, `mockImplementation`을 통해 `window.alert`가 실행됐는지 등의 정보를 확인할 수 있도록 처리한 것

### 비동기 이벤트가 발생하는 컴포넌트
- 예시 - `fetch`가 실행되는 컴포넌트
    - Test 코드
    ```tsx
    jest.spyOn(window, 'fetch').mockImplementation(
        jest.fn(() => 
            Promise.resolve({
                ok: true,
                status: 200,
                json: () => Promise.resolve(MOCK_TODO_RESPONSE),
            }),
        ) as jest.Mock,  // 실제로 정확하게 fetch를 모킹하려면 많은 구현을 해야하지만 여기선느 간단하게 json만 구현하고 어설션으로 간단하게 처리했다.
    )
    ```
    - 모든 시나리오 해결 불가 -> 테스트 할 때마다 `resolve`내부 값을 모두 바꿔가며 테스트
    - 또한 fetch가 할 수 있는 다양한 일(header 설정, text() 파싱, status 값 다르게 봄 등)을 일일이 모킹해야하므로 테스트 코드가 길어지고 유지보수도 어려움

> MSW(Mock Service Worker)
- Node.js나 브라우저에서 모두 사용할 수 있는 모킹 라이브러리로, 브라우저에서는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 구현
- Node.js 환경에서는 https나 XMLHttpRequest의 요청을 가로채는 방식
- Node.js나 브라우저에서는 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행, 이 요청 중간에 MSW가 감지하고 미리 준비한 모킹 데이터를 제공하는 방식

> 핵심
- MSW를 사용한 fetch 응답 모킹과 findBy를 활용해 비동기 요청이 끝난 뒤에 제대로된 렌더링이 일어났는지 기다린 후에 확인하는 것이다.

## 사용자 정의 훅 테스트하기
- 훅을 테스트하는 과정도 동일하게 진행, 훅이 들어가 있는 컴포넌트를 만듦 -> 테스트 코드 작성 외에 작업이 더 추가됨
- 훅이 들어있는 컴포넌트에 대해 별도로 훅에 대한 테스트를 만듦 -> 해당 훅이 모든 훅이 모든 테스트 케이스를 커버하지 못할 경우 또 다른 테스트 가능한 컴포넌트를 찾아야하는 단점

### react-hooks-testing-library 활용법
- useEffectDebugger 훅: 컴포넌트 명과 props를 인수로 받아 해당 컴포넌트가 어떤 props의 변경으로 인해 리렌더링됐는지 확인해 주는 일종의 디버거 역할

> useEffetDebugger 기능
- 최초 컴포넌트 렌더링 시에는 호출하지 않는다.
- 이전 props를 useRef에 저장해 두고, 새로운 props를 넘겨받을 때마다 이전 props와 비교해 무엇이 렌더링을 발생시켰는지 확인
- 이전 props와 신규 props의 비교는 리액트의 원리와 동일하게 Object.is를 활용해 얕은 비교 수행
- process.env.NODE_ENV === 'production'인 경우에는 로깅을 하지 않음. 이는 웹팩을 빌드 도구로 사용할 경우 일반적으로 트리쉐이킹이 이뤄지는 일종의 최적화 기법. 웹팩을 비롯한 많은 번들러에서는 process.env.NODE_ENV === 'production'인 경우에는 해당 코드가 빌드 결과물에 포함되지 않음, 이는 운영 환경에서는 해당 코드가 실행되지 않는다는 의미.

> 한계
- 어디까지나 props가 변경되는 것만 확인 가능
- 부모 컴포넌트 리렌더링되는 경우는 useEffectDebugger로 확인할 수 없음

## 테스트를 작성하기에 앞서 고려해야 할 점
- 테스트 커버리지: 해당 소프트웨어가 얼마나 테스트됐는지를 나타내는 지표
- 테스트 커버리지가 높을 수록 좋고 꾸준히 테스트 코드를 작성하라는 것이지만 만능은 아니다
- 테스트 커버리지를 100%까지 끌어올릴 수 있는 상황은 생각보다 드뭄
- TDD(Test Driven Development)라고 하는 개발 방법론을 채용하더라도 프론트엔드 특성상 사용자의 입력이 매우 자유로워 모든 상황을 커버하기 힘듦

### 결론
- 애플리케이션에서 가장 취약하거나 중요한 부분을 파악
- 가장 핵심적인 부분부터 테스트 코드를 하나씩 작성해 나가는 것이 중요
- 테스트 코드는 개발자가 단순 코드 작성만으로 쉽게 이룰 수 없는 목표인 소프트웨어 품질에 대한 확신을 얻기위해 작성

## 그 밖에 해볼 만한 여려 가지 테스트
- 유닛 테스트: 각각의 컴포넌트가 독립적으로 분리된 환경에서 의도된 대로 정확히 작동하는지 검증(리액트 테스팅 라이브러리가 도와줌)
- 통합 테스트: 유닛 테스트를 통과한 여러 컴포넌트가 묶여서 하나의 기능으로 정상 작동하는지 확인(리액트 테스팅 라이브러리가 도와줌)
- 엔드 투 엔드: 흔이 E2E 테스트라하며, 실제 사용자처럼 작동하는 로봇을 활용해 애플리케이션의 전체적인 기능을 확인하는 테스트

## 정리
# 클래스 컴포넌트와 함수 컴포넌트

## 클래스 컴포넌트
### 기본적인 클래스 컴포넌트
```jsx
import React from 'react'

class SampleComponent extends React.Component{
    render(){
        return <h2>Sample Component</h2>
    }
}
```

- `extends`할 수 있는 클래스
  - `React.Component`
  - `React.PureComponent`

### 코드를 통한 알아보기
```jsx
import React from 'react'

// props 타입을 선언
interface SampleProps {
    required?: boolean
    text: string
}

// state 타입을 선언
interface SampleState {
    count: number
    isLimited?: boolean
}

// Component에 제네릭으로 props, state를 순서대로 넣어줌
class SampleComponent extends React.Component<SampleProps, SampleState> {
    // constructor에서 props를 넘겨주고, state의 기본값을 설정
    private constuctor(props: SampleProps){
        super(props)
        this.state={
            count: 0,
            isLimited: false,
        }
    }
    
    // render 내부에서 쓰일 함수 선언
    private handleClick = () => {
        const newValue = this.state.count + 1
        this.setState({ count: newValue, isLimited: newValue >= 10 })
    }

    // render에서 이 컴포넌트가 렌더링할 내용을 정의
    public render(){
        // props와 state 값을 this, 즉 해당 클래스를 꺼냄
        const {
            props: {required, text},
            state: {count, isLimited },
        } = this

        return (
            <h2>
                Sample Component
                <div>문자: {text}</div>
                <div>count: {count}</div>
                <button onClick={this.handleClick} disable={isLimited}>
                    증가
                </button>
            </h2>
        )
    }
}
```
- `constructor`: 컴포넌트 내부에 이 생성자 함수가 있다면 컴포넌트가 초기화되는 시점에 호출한다. 여기서는 컴포넌트의 state를 초기화할 수 있다. 선언돼 있는 super는 컴포넌트를 만들면서 상속받은 상위 컴포넌트, `React.Component`의 생성자 함수를 먼저 호출해 필요한 상위 컴포넌트에 접근할 수 있게 도와준다.

> 부록) constructor 없이 state 초기활 수 있지않나요?
>```jsx
>import {Component} from 'react'
>
>class SampleComponent2 extends Component {
>    state = {
>        count: 1,
>    }
>
>    render() {
>        const {
>            state: {count},
>        } = this
>        return <div>{count}</div>
>    }
>}
>```
> - ES2022에 추가된 클래스 필드(class field) 덕분에 가능한 문법
> - 별도의 초기화 과정을 거치지 않고도 클래스 내부에 필드를 선언할 수 있게 도와줌
> - 2022이전 버전에서 사용하려면 트랜스파일 과정이 필요

- `props`: 함수에 인수를 넣는 것과 비슷하게, 컴포넌트에 특정 속성을 전달하는 용도로 쓰임
- `state`: 클래스 컴포넌트 내부에서 관리하는 값, 값에 변화가 있을 때마다 리렌더링 발생
- `메서드`: 렌더링 함수 내부에서 사용되는 함수, 보통 DOM에서 발생하는 이벤트와 함께 사용
  - 메서드를 만드는 방식 3가지
    1. `constructor`에서 `this`바인드를 하는 방법
        - 일반적인 함수로 메서드를 만들면 `this`가 `undefined`로 나옴(전역 객체, strict 모드는 undefined)
         - ex)
            ```jsx
            import { Component } from 'react'

            // 빈 Props 선언
            type Props = Record<string, never>

            interface State{
                counter: number
            }

            class SampleComponent extends Component<Props, State> {
                private constructor(props: Props) {
                    super(props)
                    this.state = {
                        count: 1,
                    }
                    // handleClick의 this를 현재 클래스로 바인딩
                    this.handleClick = this.handleClick.bind(this)
                }

                private handleClick() {
                    this.setState((prev) => ({count: prev.count+1}))
                }

                public render() {
                    const {
                        state: { count },
                    } = this
                    return (
                        <div>
                            <button onClick={this.handleClick}>증가</button>
                        </div>
                    )
                }
            }
            ```
            - 화살표 함수를 쓴다면 작성 시점에 this가 상위 스코프로 결정되므로 굳이 바인딩하지 않아도됨
    2. 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법
        - ex)
            ```jsx
            <button onClick={() => this.handleClick()}>증가</button>
            ```
        - 최적화가 어려움(렌더링 시마다 새로운 함수 생성)

### 클래스 컴포넌트의 생명주기 메서드

### 클래스 컴포넌트의 한계

## 함수 컴포넌트

## 함수 컴포넌트 vs 클래스 컴포넌트

## 정리
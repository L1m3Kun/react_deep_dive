# 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
- 리액트 제공 API 중 `useMemo`와 `useCallback` 훅과 고차 컴포넌트인 `memo`는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해 제공
- 언제 사용하면 좋을까?

## 대전제
- 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다.
- 해당 컴포넌트가 렌더링이 자주 일어나며 그 렌더링 사이에 비싼 연산이 포함돼 있고, 그 컴포넌트가 자식 컴포넌트 또한 많이 가지고 있다면 메모이제이션을 사용하는 것이 이점이 될 수 있다.

## 주장 1: 섣부른 최적화는 독이다, 꼭 필요한 곳에만 메모이제이션을 추가하자
- 꼭 필요한 곳을 신중히 골라서 메모이제이션 해야한다는 입장
- 메모이제이션 비용: (값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업) + (이전 결과물을 저장해 두었다가 다시 꺼내오는 작업)
- 렌더링 비용보다 저렴한가?
- 따라서 섣불리 최적화하는 것은 옳지 못하다

## 주장 2: 렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자
- 리액트 애플리케이션의 규모가 커지고, 개발자와 컴포넌트의 복잡성이 증가하는 상황에서 모두 메모이제이션하지 않았을 때보다 모두 메모이제이션 했을 때 더 많은 이점이 있다.
- 리액트는 기본 재조정 알고리즘을 수행하기 위해 이미 이전 결과물을 저장해두어  잘못된 메모이제이션이 불러오는 비용은 앝은 비교가 발생하면서 지불해야하는 비용밖에 없다. 
- 메모이제이션을 하지 않았을 때 발생할 수 있는 문제
    - 렌더링을 함으로써 발생하는 비용
    - 컴포넌트 내부의 복잡한 로직의 재실행
    - 위 두가지 모두가 모든 자식 컴포넌트에서 반복해서 일어나는 비용
    - 리액트가 구 트리와 신규 트리를 비교

## 결론 및 정리
1. 충분한 시간이 있으며, 배우는 중간이라면 주장 1에 따라 적절한 메모이제이션을 적용하는 연습은 필수불가결
2. 하지만 시간이 부족한 현업 같은 경우 의심가는 곳은 모두 메모이제이션을 적용하는 것이 더 나을 수 있다.

